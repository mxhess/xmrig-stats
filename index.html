<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMRig Proxy Stats</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #0f0;
            padding: 10px;
            line-height: 1.2;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            border: 1px solid #0f0;
        }
        
        .header {
            text-align: center;
            padding: 5px;
            border-bottom: 1px solid #0f0;
        }
        
        .header h1 {
            color: #0f0;
            font-size: 1.2em;
            margin: 0;
        }
        
        .config-section {
            padding: 5px;
            border-bottom: 1px solid #0f0;
        }
        
        .config-inputs {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .config-inputs .input-row {
            display: flex;
            gap: 5px;
            width: 100%;
        }
        
        .config-inputs .button-row {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        
        .config-inputs label {
            color: #0f0;
            font-weight: normal;
            min-width: 80px;
        }
        
        .config-inputs input {
            padding: 2px;
            border: 1px solid #0f0;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            width: 120px;
        }
        
        .config-inputs button {
            padding: 2px 5px;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            cursor: pointer;
        }
        
        .config-inputs button:hover {
            background: #0f0;
            color: #000;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .status-online { background: #0f0; }
        .status-offline { background: #f00; }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2px;
            padding: 5px;
            border-bottom: 1px solid #0f0;
        }
        
        .stat-card {
            border: 1px solid #0f0;
            padding: 5px;
        }
        
        #hashrate-chart-card {
            grid-column: 1 / -1; /* Span full width */
            position: relative;
        }
        
        #hashrate-chart {
            width: 100%;
            height: 100px;
            border: 1px solid #0f0;
            background: #000;
            display: block;
            cursor: crosshair;
        }
        
        .chart-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            margin-top: 3px;
            color: #0f0;
        }
        
        .chart-current {
            flex: 1;
            text-align: center;
            font-weight: bold;
        }
        
        .chart-tooltip {
            position: absolute;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 6px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            line-height: 1.2;
        }
        
        .stat-card h3 {
            color: #0f0;
            font-size: 1em;
            margin: 0 0 2px 0;
        }
        
        .stat-value {
            font-size: 1em;
            font-weight: normal;
            color: #0f0;
            margin: 0;
        }
        
        .workers-section {
            padding: 5px;
            border: 1px solid #0f0;
            margin-top: 5px;
        }
        
        .workers-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .workers-table th,
        .workers-table td {
            padding: 2px;
            text-align: left;
            border: 1px solid #0f0;
            font-size: 0.9em;
        }
        
        .workers-table th {
            background: #000;
            color: #0f0;
            font-weight: normal;
        }
        
        .workers-table tr:hover {
            background: #001a00;
        }
        
        .error-message {
            background: #300;
            color: #f00;
            padding: 5px;
            border: 1px solid #f00;
            margin: 5px 0;
        }
        
        .loading {
            text-align: center;
            padding: 5px;
            color: #0f0;
        }
        
        .refresh-info {
            text-align: center;
            color: #0f0;
            padding: 5px;
            font-size: 0.8em;
        }
        
        .editable-interval {
            cursor: pointer;
            border-bottom: 1px dashed #0f0;
            padding: 0 2px;
        }
        
        .editable-interval:focus {
            outline: none;
            border-bottom: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>XMRig Proxy Stats Dashboard</h1>
            <div id="connection-status">
                <span class="status-indicator status-offline"></span>
                <span>Disconnected</span>
            </div>
        </div>
        
        <div class="config-section">
            <div class="config-inputs">
                <div class="input-row">
                    <label for="backend-host">Backend Host:</label>
                    <input type="text" id="backend-host" value="127.0.0.1" placeholder="127.0.0.1">
                    <label for="backend-port">Backend Port:</label>
                    <input type="number" id="backend-port" value="8000" placeholder="8000">
                </div>
                <div class="button-row">
                    <button onclick="updateConfig()">Connect</button>
                    <button onclick="toggleAutoRefresh()" id="auto-refresh-btn">Enable Auto-refresh</button>
                </div>
            </div>
        </div>
        
        <div id="error-container"></div>
        
        <div id="stats-container" style="display: none;">
            <div class="stats-grid">
                <div class="stat-card" id="hashrate-chart-card">
                    <h3>Hashrate Chart (<span id="chart-window-label">30m</span>)</h3>
                    <canvas id="hashrate-chart" width="800" height="100"></canvas>
                    <div class="chart-info">
                        <span id="chart-max">Max: --</span>
                        <span class="chart-current" id="chart-current">Current: --</span>
                        <span id="chart-min">Min: --</span>
                    </div>
                    <div class="chart-tooltip" id="chart-tooltip"></div>
                </div>
                <div class="stat-card">
                    <h3>Accepted Shares</h3>
                    <div class="stat-value" id="accepted-shares">0</div>
                </div>
                <div class="stat-card">
                    <h3>Connected Workers</h3>
                    <div class="stat-value" id="workers-count">0</div>
                </div>
                <div class="stat-card">
                    <h3>Uptime</h3>
                    <div class="stat-value" id="uptime">0</div>
                </div>
                <div class="stat-card">
                    <h3>Active Upstreams</h3>
                    <div class="stat-value" id="upstreams-count">0</div>
                </div>
            </div>
            
            <div class="workers-section">
                <h3>Active Workers</h3>
                <table class="workers-table">
                    <thead>
                        <tr>
                            <th>Worker ID</th>
                            <th>IP Address</th>
                            <th>Accepted</th>
                            <th>Rejected</th>
                            <th>Difficulty</th>
                            <th>10m Rate</th>
                            <th>24h Rate</th>
                        </tr>
                    </thead>
                    <tbody id="workers-tbody">
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="refresh-info">
            <div id="last-update">Never updated</div>
            <div>Auto-refresh: <span id="auto-refresh-status">Disabled</span> (<span id="refresh-interval" class="editable-interval" contenteditable="true">5</span>s)</div>
        </div>
    </div>

    <script>
        let backendHost = '127.0.0.1';
        let backendPort = 8000;
        let autoRefreshInterval = null;
        let isAutoRefresh = false;
        let workersData = { workers: [] };
        let minersData = { miners: [] };
        let refreshIntervalValue = 5; // Default interval in seconds
        let hashrateHistory = []; // Store hashrate history for chart
        let hashrateChart = null;
        let chartStartTime = null; // Track when we started collecting data

        function updateConfig() {
            backendHost = document.getElementById('backend-host')?.value || '127.0.0.1';
            backendPort = document.getElementById('backend-port')?.value || 8000;
            fetchStats();
        }

        function toggleAutoRefresh() {
            if (isAutoRefresh) {
                clearInterval(autoRefreshInterval);
                isAutoRefresh = false;
                const autoRefreshBtn = document.getElementById('auto-refresh-btn');
                const autoRefreshStatus = document.getElementById('auto-refresh-status');
                if (autoRefreshBtn) autoRefreshBtn.textContent = 'Enable Auto-refresh';
                if (autoRefreshStatus) autoRefreshStatus.textContent = 'Disabled';
            } else {
                autoRefreshInterval = setInterval(fetchStats, refreshIntervalValue * 1000);
                isAutoRefresh = true;
                const autoRefreshBtn = document.getElementById('auto-refresh-btn');
                const autoRefreshStatus = document.getElementById('auto-refresh-status');
                if (autoRefreshBtn) autoRefreshBtn.textContent = 'Disable Auto-refresh';
                if (autoRefreshStatus) autoRefreshStatus.textContent = 'Enabled';
                fetchStats();
            }
        }

        function updateRefreshInterval(element) {
            console.log('Updating refresh interval');
            let newInterval = parseInt(element.textContent.trim(), 10) || 5;
            if (newInterval < 1) newInterval = 5;
            refreshIntervalValue = newInterval;
            element.textContent = newInterval;
            console.log('Updated refresh interval to:', refreshIntervalValue, 'seconds');
            if (isAutoRefresh) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = setInterval(fetchStats, refreshIntervalValue * 1000);
                console.log('New interval set to:', refreshIntervalValue * 1000, 'ms');
            }
        }

        // Add event listeners after DOM load
        document.addEventListener('DOMContentLoaded', () => {
            const refreshInterval = document.getElementById('refresh-interval');
            if (refreshInterval) {
                console.log('Refresh interval element found');
                refreshInterval.addEventListener('focus', () => {
                    console.log('Refresh interval focused');
                });
                document.addEventListener('click', (event) => {
                    if (!refreshInterval.contains(event.target)) {
                        console.log('Click outside refresh interval, attempting to update');
                        updateRefreshInterval(refreshInterval);
                    }
                });
            } else {
                console.error('Refresh interval element not found');
            }
            initHashrateChart();
            fetchStats();
        });

        function initHashrateChart() {
            const canvas = document.getElementById('hashrate-chart');
            if (!canvas) {
                console.error('Hashrate chart canvas not found');
                return;
            }
            hashrateChart = canvas.getContext('2d');
            
            // Add mouse event listeners for tooltip
            canvas.addEventListener('mousemove', handleChartMouseMove);
            canvas.addEventListener('mouseleave', handleChartMouseLeave);
            
            drawHashrateChart();
        }

        function handleChartMouseMove(event) {
            if (hashrateHistory.length === 0) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            
            // Calculate scaling ratio between display size and internal canvas size
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // Get mouse position relative to canvas and scale to internal coordinates
            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;
            
            // Chart dimensions (same as in drawHashrateChart)
            const leftMargin = 50;
            const rightMargin = 10;
            const chartWidth = canvas.width - leftMargin - rightMargin;
            
            // Check if mouse is within chart area
            if (mouseX < leftMargin || mouseX > leftMargin + chartWidth) {
                hideTooltip();
                return;
            }
            
            // Calculate which data point is closest to mouse position
            const relativeX = (mouseX - leftMargin) / chartWidth;
            
            // Get current time window
            const now = Date.now() / 1000; // Convert to seconds
            const windowDuration = getTimeWindowDuration() / 1000; // Convert to seconds
            const windowStart = isInSlidingMode() ? now - windowDuration : (chartStartTime || now);
            
            // Find the closest data point
            let closestPoint = null;
            let closestDistance = Infinity;
            
            hashrateHistory.forEach(point => {
                const pointRelativePosition = (point.timestamp - windowStart) / windowDuration;
                if (pointRelativePosition >= 0 && pointRelativePosition <= 1) {
                    const distance = Math.abs(pointRelativePosition - relativeX);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPoint = point;
                    }
                }
            });
            
            if (closestPoint) {
                // Use mouse position relative to canvas for tooltip positioning
                const mouseRelativeX = event.clientX - rect.left;
                const mouseRelativeY = event.clientY - rect.top;
                showTooltip(mouseRelativeX, mouseRelativeY, closestPoint, canvas);
                // Redraw chart with highlight
                drawHashrateChart(closestPoint);
            } else {
                hideTooltip();
            }
        }

        function handleChartMouseLeave() {
            hideTooltip();
            drawHashrateChart(); // Redraw without highlight
        }

        function showTooltip(relativeX, relativeY, dataPoint, canvas) {
            const tooltip = document.getElementById('chart-tooltip');
            if (!tooltip) return;
            
            const time = new Date(dataPoint.timestamp * 1000).toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: '2-digit',
                second: '2-digit',
                timeZone: 'America/Denver'
            });
            
            tooltip.innerHTML = `${time}<br>${formatHashrate(dataPoint.hashrate)}`;
            tooltip.style.display = 'block';
            
            // Get canvas position and chart container position
            const canvasRect = canvas.getBoundingClientRect();
            const chartContainer = document.getElementById('hashrate-chart-card');
            const containerRect = chartContainer.getBoundingClientRect();
            
            // Position tooltip relative to the chart container
            const tooltipX = relativeX + 10; // Small offset from cursor
            const tooltipY = relativeY - 40; // Above the cursor
            
            // Convert to position relative to chart container
            const containerRelativeX = canvasRect.left - containerRect.left + tooltipX;
            const containerRelativeY = canvasRect.top - containerRect.top + tooltipY;
            
            tooltip.style.left = containerRelativeX + 'px';
            tooltip.style.top = containerRelativeY + 'px';
        }

        function hideTooltip() {
            const tooltip = document.getElementById('chart-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        function addHashrateDataPoint(hashrate, timestamp) {
            const now = timestamp || Date.now() / 1000; // Convert to seconds
            
            // Set start time on first data point
            if (chartStartTime === null) {
                chartStartTime = now;
            }
            
            hashrateHistory.push({ hashrate, timestamp: now });
            
            // Remove any data points that are more than 3 hours old
            const threeHoursAgo = now - (3 * 60 * 60);
            hashrateHistory = hashrateHistory.filter(point => point.timestamp > threeHoursAgo);
            
            drawHashrateChart();
        }

        function getTimeWindowDuration() {
            if (chartStartTime === null) return 30 * 60 * 1000; // Default 30 minutes
            
            const elapsedMinutes = (Date.now() / 1000 - chartStartTime) / 60;
            
            if (elapsedMinutes < 30) return 30 * 60 * 1000;        // 30 minutes
            if (elapsedMinutes < 60) return 60 * 60 * 1000;        // 1 hour
            if (elapsedMinutes < 90) return 90 * 60 * 1000;        // 1.5 hours
            if (elapsedMinutes < 120) return 120 * 60 * 1000;      // 2 hours
            if (elapsedMinutes < 180) return 180 * 60 * 1000;      // 3 hours
            
            return 180 * 60 * 1000; // 3 hours (sliding window mode)
        }

        function getWindowLabel() {
            if (chartStartTime === null) return "30m";
            
            const elapsedMinutes = (Date.now() / 1000 - chartStartTime) / 60;
            
            if (elapsedMinutes < 30) return "30m";
            if (elapsedMinutes < 60) return "1h";
            if (elapsedMinutes < 90) return "1.5h";
            if (elapsedMinutes < 120) return "2h";
            if (elapsedMinutes < 180) return "3h";
            
            return "3h"; // sliding window
        }

        function isInSlidingMode() {
            if (chartStartTime === null) return false;
            const elapsedMinutes = (Date.now() / 1000 - chartStartTime) / 60;
            return elapsedMinutes >= 180;
        }

        function drawHashrateChart(highlightPoint = null) {
            if (!hashrateChart) return;
            
            const canvas = document.getElementById('hashrate-chart');
            const ctx = hashrateChart;
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Update window label
            const windowLabel = document.getElementById('chart-window-label');
            if (windowLabel) windowLabel.textContent = getWindowLabel();
            
            // Calculate time window based on elapsed time
            const now = Date.now() / 1000; // Convert to seconds
            const windowDuration = getTimeWindowDuration() / 1000; // Convert to seconds
            const windowStart = isInSlidingMode() ? now - windowDuration : (chartStartTime || now);
            const windowEnd = windowStart + windowDuration;
            
            // Calculate min/max for scaling (only if we have data)
            let minHashrate = 0;
            let maxHashrate = 100; // Default range
            let currentHashrate = 0;
            
            if (hashrateHistory.length > 0) {
                const hashrates = hashrateHistory.map(point => point.hashrate);
                minHashrate = Math.min(...hashrates);
                maxHashrate = Math.max(...hashrates);
                currentHashrate = hashrateHistory[hashrateHistory.length - 1].hashrate;
                
                // Add some padding to the range
                const range = maxHashrate - minHashrate || 1;
                const padding = range * 0.1;
                minHashrate = Math.max(0, minHashrate - padding);
                maxHashrate = maxHashrate + padding;
            }
            
            // Update info display below chart
            const maxElement = document.getElementById('chart-max');
            const minElement = document.getElementById('chart-min');
            const currentElement = document.getElementById('chart-current');
            if (maxElement) maxElement.textContent = hashrateHistory.length > 0 ? `Max: ${formatHashrate(Math.max(...hashrateHistory.map(p => p.hashrate)))}` : 'Max: --';
            if (minElement) minElement.textContent = hashrateHistory.length > 0 ? `Min: ${formatHashrate(Math.min(...hashrateHistory.map(p => p.hashrate)))}` : 'Min: --';
            if (currentElement) currentElement.textContent = hashrateHistory.length > 0 ? `Current: ${formatHashrate(currentHashrate)}` : 'Current: --';
            
            // Margins for axes
            const leftMargin = 50;
            const bottomMargin = 20;
            const topMargin = 10;
            const rightMargin = 10;
            const chartWidth = width - leftMargin - rightMargin;
            const chartHeight = height - topMargin - bottomMargin;
            
            // Draw Y-axis labels and grid lines
            ctx.fillStyle = '#0f0';
            ctx.font = '10px Courier New';
            ctx.strokeStyle = '#003300';
            ctx.lineWidth = 0.5;
            
            const ySteps = 5;
            const range = maxHashrate - minHashrate;
            for (let i = 0; i <= ySteps; i++) {
                const value = minHashrate + (range * i / ySteps);
                const y = topMargin + chartHeight - (i / ySteps * chartHeight);
                
                // Y-axis label
                ctx.fillText(formatHashrate(value), 2, y + 3);
                
                // Horizontal grid line
                if (i > 0) {
                    ctx.beginPath();
                    ctx.moveTo(leftMargin, y);
                    ctx.lineTo(leftMargin + chartWidth, y);
                    ctx.stroke();
                }
            }
            
            // Draw X-axis time labels and grid lines
            const xSteps = Math.min(6, Math.max(3, Math.floor(windowDuration / (30 * 60)))); // Adaptive steps
            for (let i = 0; i <= xSteps; i++) {
                const timeOffset = windowDuration * (i / xSteps);
                const time = new Date((windowStart + timeOffset) * 1000); // Convert back to milliseconds
                const x = leftMargin + (i / xSteps * chartWidth);
                
                // X-axis label
                const timeStr = time.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    timeZone: 'America/Denver'
                });
                ctx.fillText(timeStr, x - 15, height - 5);
                
                // Vertical grid line
                if (i > 0 && i < xSteps) {
                    ctx.beginPath();
                    ctx.moveTo(x, topMargin);
                    ctx.lineTo(x, topMargin + chartHeight);
                    ctx.stroke();
                }
            }
            
            // Draw hashrate line (only if we have data)
            if (hashrateHistory.length > 1) {
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                let firstPoint = true;
                let highlightX = null;
                let highlightY = null;
                
                hashrateHistory.forEach((point, index) => {
                    // Calculate x position based on timestamp relative to current time window
                    const relativePosition = (point.timestamp - windowStart) / windowDuration;
                    
                    // Only draw points that fall within our current window
                    if (relativePosition >= 0 && relativePosition <= 1) {
                        const x = leftMargin + (relativePosition * chartWidth);
                        const normalizedHashrate = (point.hashrate - minHashrate) / range;
                        const y = topMargin + chartHeight - (normalizedHashrate * chartHeight);
                        
                        // Check if this is the highlight point
                        if (highlightPoint && point.timestamp === highlightPoint.timestamp) {
                            highlightX = x;
                            highlightY = y;
                        }
                        
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                });
                ctx.stroke();
                
                // Draw highlight dot if we have a highlight point
                if (highlightX !== null && highlightY !== null) {
                    ctx.fillStyle = '#0f0';
                    ctx.beginPath();
                    ctx.arc(highlightX, highlightY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Draw Y-axis line
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(leftMargin, topMargin);
            ctx.lineTo(leftMargin, topMargin + chartHeight);
            ctx.stroke();
            
            // Draw X-axis line
            ctx.beginPath();
            ctx.moveTo(leftMargin, topMargin + chartHeight);
            ctx.lineTo(leftMargin + chartWidth, topMargin + chartHeight);
            ctx.stroke();
        }

        async function fetchStats() {
            const baseUrl = `http://${backendHost}:${backendPort}`;
            try {
                showLoading();
                clearError();

                // Fetch all stats from backend
                const response = await fetch(`${baseUrl}/stats`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch stats: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                
                if (!data.summary) {
                    throw new Error('No valid summary data received. Check backend configuration.');
                }

                // Update hashrate history
                if (data.hashrateHistory && Array.isArray(data.hashrateHistory)) {
                    hashrateHistory = data.hashrateHistory.map(point => ({
                        timestamp: point.timestamp,
                        hashrate: parseFloat(point.hashrate)
                    }));
                }

                updateUI(data.summary, data.workers, data.miners);
                setConnectionStatus(true);
                const lastUpdate = document.getElementById('last-update');
                if (lastUpdate) {
                    lastUpdate.textContent = `Last updated: ${new Date().toLocaleTimeString('en-US', { timeZone: 'America/Denver' })}`;
                } else {
                    console.error('Element with ID "last-update" not found in DOM');
                }
            } catch (error) {
                console.error('Error in fetchStats:', error);
                showError(`Failed to connect to backend: ${error.message}. Check that backend is running and port is correct.`);
                setConnectionStatus(false);
            }
        }

        function updateUI(summary = {}, workersData = { workers: [] }, minersData = { miners: [] }) {
            const statsContainer = document.getElementById('stats-container');
            if (!statsContainer) {
                console.error('Element with ID "stats-container" not found in DOM');
                return;
            }
            statsContainer.style.display = 'block';

            const updateElement = (id, value) => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value;
                } else {
                    console.error(`Element with ID "${id}" not found in DOM`);
                }
            };

            updateElement('workers-count', summary.miners?.now || summary.workers || 0);
            updateElement('accepted-shares', summary.results?.accepted || 0);
            updateElement('upstreams-count', summary.upstreams?.active || 0);
            updateElement('uptime', formatUptime(summary.uptime || 0));

            const workersTbody = document.getElementById('workers-tbody');
            if (!workersTbody) {
                console.error('Element with ID "workers-tbody" not found in DOM');
                return;
            }
            workersTbody.innerHTML = '';
            
            if (workersData?.workers && Array.isArray(workersData.workers) && workersData.workers.length > 0) {
                const activeWorkers = workersData.workers.filter(worker => worker[2] > 0); // Filter out workers with Connection count = 0 (index 2)
                if (activeWorkers.length > 0) {
                    activeWorkers.forEach(worker => {
                        const workerId = worker[0] || 'Unknown';
                        const workerIp = worker[1] || 'Unknown';
                        const accepted = worker[3] || 0;
                        const rejected = worker[4] || 0;
                        
                        // Get hashrate data (10m and 24h)
                        const hashrate10m = worker[9] || 0;
                        const hashrate24h = worker[12] || 0;
                        
                        // Find matching miner for difficulty
                        let difficulty = 'N/A';
                        if (minersData?.miners && Array.isArray(minersData.miners)) {
                            const matchingMiner = minersData.miners.find(miner => {
                                // Match by IP address or rig_id
                                return miner[1] === workerIp || miner[8] === workerId;
                            });
                            if (matchingMiner && matchingMiner[5]) {
                                difficulty = formatDifficulty(matchingMiner[5]);
                            }
                        }
                        
                        const row = workersTbody.insertRow();
                        row.innerHTML = `
                            <td>${workerId}</td>
                            <td>${workerIp}</td>
                            <td>${accepted}</td>
                            <td>${rejected}</td>
                            <td>${difficulty}</td>
                            <td>${formatHashrate(hashrate10m)}</td>
                            <td>${formatHashrate(hashrate24h)}</td>
                        `;
                    });
                } else {
                    const row = workersTbody.insertRow();
                    row.innerHTML = '<td colspan="7" style="text-align: center; color: #0f0;">No active workers with connections</td>';
                }
            } else {
                const row = workersTbody.insertRow();
                row.innerHTML = '<td colspan="7" style="text-align: center; color: #0f0;">No worker details available</td>';
            }
        }

        function formatHashrate(hashrate) {
            if (hashrate >= 1000) {
                return (hashrate / 1000).toFixed(2) + ' MH/s';
            } else if (hashrate >= 1) {
                return hashrate.toFixed(2) + ' kH/s';
            }
            return hashrate.toFixed(2) + ' H/s';
        }

        function formatDifficulty(difficulty) {
            if (difficulty >= 1000000) {
                return (difficulty / 1000000).toFixed(2) + 'M';
            } else if (difficulty >= 1000) {
                return (difficulty / 1000).toFixed(1) + 'K';
            }
            return difficulty.toString();
        }

        function formatUptime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            }
            return `${secs}s`;
        }

        function setConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            const indicator = statusEl?.querySelector('.status-indicator');
            const text = statusEl?.querySelector('span:last-child');
            if (!statusEl || !indicator || !text) {
                console.error('Connection status elements missing in DOM');
                return;
            }
            indicator.className = `status-indicator ${connected ? 'status-online' : 'status-offline'}`;
            text.textContent = connected ? 'Connected' : 'Disconnected';
        }

        function showError(message) {
            const container = document.getElementById('error-container');
            if (!container) {
                console.error('Element with ID "error-container" not found in DOM');
                return;
            }
            container.innerHTML = `<div class="error-message">${message}</div>`;
            const statsContainer = document.getElementById('stats-container');
            if (statsContainer) statsContainer.style.display = 'none';
        }

        function clearError() {
            const container = document.getElementById('error-container');
            if (container) container.innerHTML = '';
        }

        function showLoading() {
            const container = document.getElementById('error-container');
            if (container) container.innerHTML = '<div class="loading">Loading...</div>';
        }

        // Wait for DOM to load
        document.addEventListener('DOMContentLoaded', fetchStats);
    </script>
</body>
</html>

